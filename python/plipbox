#!/usr/bin/env python2.7

from __future__ import print_function

import sys, os
import time
import argparse
import threading
import traceback

import veth
import pbvpar
from ethframe import EthFrame, MacAddress
from pktdecode import PacketDecoder

# ---------- common --------------------------------------------------------

class Reader:

  def __init__(self, name, args, log, ts_base, decoder=None):
    self.name = name
    self.args = args
    self.log = log
    self.decoder = decoder
    self.ts_base = ts_base

  def log_packet(self, eth_frame, raw_pkt, tag):
    # nothing to do
    if not args.verbose:
      return
    # filter all
    if not args.all_packets and tag is not None:
      return
    # tag == None -> ok
    if tag is None:
      tag = " ok "
    # get a timestamp
    t = time.time() - ts_base
    # try to decode packet
    if self.decoder is not None:
      info = self.decoder.decode_raw_pkt(raw_pkt)
    else:
      info = None
    # if decoding fails use eth frame
    if info is None:
      info = eth_frame.__str__()
    self.log("%12.6f %s: [%4d] [%s]" % (t, self.name, len(raw_pkt), tag), info)

# ---------- ethernet ------------------------------------------------------

class EthernetReader(Reader):

  def __init__(self, eth_io, args, log, ts_base, decoder):
    Reader.__init__(self, "eth", args, log, ts_base, decoder)
    # setup virtual ethernet
    try:
      eth_io.open()
    except Exception as e:
      print("veth: error opening:",e)
      sys.exit(1)
    self.eth_io = eth_io

  def tx_pkt(self, raw_buf):
    self.eth_io.tx_pkt(raw_buf)

  def set_env(self, pb, leave_event, online_event, pb_mac):
    self.pb = pb
    self.leave_event = leave_event
    self.online_event = online_event
    self.pb_mac = pb_mac

  def run(self):
    try:
      self.log("starting ethernet reader")
      timeout = 0.5
      while not self.leave_event.is_set():
        # read packet
        raw_buf = self.eth_io.rx_pkt(timeout=timeout)
        if raw_buf is not None:
          # decode frame
          eth_frame = EthFrame()
          eth_frame.decode(raw_buf)
          # send packet to plipbox
          if not args.rx and online_event.is_set():
            # check if packet is passed
            keep = args.eth_pass or eth_frame.is_for_me(plipbox_mac)
            if keep:
              # submit to par send
              self.pb.tx_pkt(raw_buf)
              tag = None
            else:
              tag = "FILT"
          else:
            tag = "OFF "
          # decode packet
          self.log_packet(eth_frame, raw_buf, tag)
    except KeyboardInterrupt:
      self.log("BREAK [eth]")
      self.leave_event.set()
    except Exception as e:
      self.log("Unexpected error:", e)
      traceback.print_exc()
    finally:
      self.log("closing ethernet reader")
      self.eth_io.close()
      self.log("ethernet done")

# ---------- plipbox -------------------------------------------------------

class PlipboxReader(Reader):

  def __init__(self, pb_io, args, log, ts_base, decoder):
    Reader.__init__(self, "PAR", args, log, ts_base, decoder)
    # setup plipbox
    try:
      pb_io.open()
    except Exception as e:
      print("pb: error opening:",e)
      sys.exit(3)
    self.pb_io = pb_io

  def tx_pkt(self, raw_buf):
    self.pb_io.tx_pkt(raw_buf)

  def set_env(self, eth, leave_event, online_event):
    self.eth = eth
    self.leave_event = leave_event
    self.online_event = online_event

  def run(self):
    try:
      self.log("starting plipbox reader")
      timeout = 0.5
      while not self.leave_event.is_set():
        # was a buffer received?
        raw_buf = self.pb_io.rx_pkt(timeout)
        if raw_buf is not None:
          # decode frame
          eth_frame = EthFrame()
          eth_frame.decode(raw_buf)
          n = len(raw_buf)
          # check for magic packets
          if eth_frame.is_magic_online():
            my_mac = eth_frame.src_mac
            log("magic: online: ", my_mac, True)
            tag = "M:ON"
            self.decoder.my_mac = my_mac
            self.online_event.set()
          elif eth_frame.is_magic_offline():
            log("magic: offline", True)
            tag = "M:OF"
            self.online_event.clear()
          elif not args.rx and self.online_event.is_set():
            try:
              tag = None
              self.eth.tx_pkt(raw_buf)
            except OSError as e:
              self.log(e)
              tag = "ERR!"
          else:
            tag = "OFF "
          # decode packet
          self.log_packet(eth_frame, raw_buf, tag)
    except KeyboardInterrupt:
      self.log("BREAK [pb]")
      self.leave_event.set()
    except Exception as e:
      self.log("Unexpected error:", e)
      traceback.print_exc()
    finally:
      self.log("closing plipbox")
      self.pb_io.close()
      self.log("plipbox done")

# ---------- main -----------------------------------------------------------
print("Welcome to plipbox!")

# default param
plipbox_mac = MacAddress((0x1a,0x11,0xaf,0xa0,0x47,0x11))

# parse args
parser = argparse.ArgumentParser()
parser.add_argument('-r', '--rx', action='store_true', default=False, help="only receive")

parser.add_argument('-e', '--eth-if', default="en1", help="ethernet interface name")
parser.add_argument('-t', '--tap-if', default="tap0", help="tap interface name")
parser.add_argument('-b', '--bridge-if', default="bridge1", help="bridge interface name")

parser.add_argument('-l', '--vpar-link', default="/tmp/vpar", help="link name for vpar pty")
parser.add_argument('-v', '--verbose', action='store_true', default=False, help="be verbose and dump packets")
parser.add_argument('-a', '--all-packets', action='store_true', default=False, help="show all packets")
parser.add_argument('-d', '--debug', type=int, default=0, help="debug flags: 1=low level, 2=protocol")
parser.add_argument('-E', '--eth-pass', action='store_true', default=False, help="pass all packets on ethernet")
args = parser.parse_args()

def log(*v,**kw):
  global args
  if args.verbose or 'force' in kw:
    print(*v)

# setup plipbox and ethernet
ts_base = time.time()
decoder = PacketDecoder(plipbox_mac)

# setup io modules
ifs = (args.eth_if, args.tap_if, args.bridge_if)
print(ifs)
eth_io = veth.VEth(*ifs)
pb_io = pbvpar.PBVPar(args.vpar_link, debug=args.debug)

# setup reader
eth = EthernetReader(eth_io, args, log, ts_base, decoder)
pb = PlipboxReader(pb_io, args, log, ts_base, decoder)

# setup shared env
leave_event = threading.Event()
online_event = threading.Event()
pb.set_env(eth, leave_event, online_event)
eth.set_env(pb, leave_event, online_event, plipbox_mac)

# start reader threads
eth_thread = threading.Thread(target=eth.run)
pb_thread = threading.Thread(target=pb.run)
if eth_thread is not None:
  eth_thread.start()
if pb_thread is not None:
  pb_thread.start()

# main thread waiting for leave event to be set
try:
  log("enter main loop")
  while True:
    leave_event.wait(0.5)
except KeyboardInterrupt:
  log("BREAK [main]")
  leave_event.set()

# shut down
if eth_thread is not None:
  log("joining ethernet")
  eth_thread.join()
if pb_thread is not None:
  log("joining plipbox")
  pb_thread.join()
log("done")
print("exit plipbox")

