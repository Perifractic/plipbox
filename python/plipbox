#!/usr/bin/env python2.7

from __future__ import print_function

import sys, os
import time
import argparse
from select import select

import veth
import pbvpar
from ethframe import EthFrame

# default param
plipbox_mac = (0x1a,0x11,0xaf,0xa0,0x47,0x11)

# parse args
parser = argparse.ArgumentParser()
parser.add_argument('-r', '--rx', action='store_true', default=False, help="only receive")

parser.add_argument('-e', '--eth-if', default="en1", help="ethernet interface name")
parser.add_argument('-t', '--tap-if', default="tap0", help="tap interface name")
parser.add_argument('-b', '--bridge-if', default="bridge0", help="bridge interface name")

parser.add_argument('-l', '--vpar-link', default="/tmp/vpar", help="link name for vpar pty")
parser.add_argument('-v', '--verbose', action='store_true', default=False, help="be verbose")
parser.add_argument('-d', '--debug', type=int, default=0, help="debug flags: 1=low level, 2=protocol")
parser.add_argument('-E', '--eth-pass', action='store_true', default=False, help="pass all packets on ethernet")
args = parser.parse_args()

# ----- eth frame decoding -----

def log(*v,**kv):
  global args
  if args.verbose:
    print(*v,**kv)

def handle_eth(veth, pb, t, args):
  global online, plipbox_mac
  # read packet
  raw_buf = veth.rx_pkt()
  # decode frame
  eth_frame = EthFrame()
  eth_frame.decode(raw_buf)
  # send packet to plipbox
  if not args.rx and online:
    # check if packet is passed
    keep = args.eth_pass or eth_frame.is_for_me(plipbox_mac)
    if keep:
      # submit to par send
      must_handle = pb.tx_pkt(raw_buf, t)
      tag = " ok "
      return must_handle
    else:
      tag = "FILT"
  else:
    tag = "OFF "
  log("%12.6f eth: [%4d] [%s]" % (t, len(raw_buf), tag), eth_frame)
  return False

def handle_pb(pb, veth, t, args):
  global online
  # was a buffer received?
  raw_buf = pb.rx_pkt(t)
  if raw_buf != None:
    # decode frame
    eth_frame = EthFrame()
    eth_frame.decode(raw_buf)
    n = len(raw_buf)
    # check for magic packets
    if eth_frame.is_magic_online():
      log("magic: online")
      tag = "M:ON"
      online = True
    elif eth_frame.is_magic_offline():
      log("magic: offline")
      tag = "M:OF"
      online = False
    elif not args.rx and online:
        try:
          tag = " ok "
          veth.tx_pkt(raw_buf)
        except OSError as e:
          log(e)
          tag = "ERR!"
    else:
      tag = "OFF "
    log("%12.6f PAR: [%4d] [%s]" % (t,len(raw_buf), tag), eth_frame)

def setup_veth(args):
  # setup virtual ethernet
  ifs = (args.eth_if, args.tap_if, args.bridge_if)
  v = veth.VEth(*ifs)
  if not v.pre_check_ifs():
    print("veth: interface problem!",*ifs)
    sys.exit(1)
  try:
    v.open()
  except Exception as e:
    print("veth: error opening:",e)
    sys.exit(2)
  return v

def setup_pbvpar(args):
  global log
  pb = pbvpar.PBVPar(args.vpar_link, debug=args.debug, log=log)
  try:
    pb.open()
  except Exception as e:
    print("pb: error opening:",e)
    sys.exit(3)
  return pb

# ----- main loop -----
print("Welcome to plipbox!")

# setup plipbox
pb = setup_pbvpar(args)
sp_fd = pb.sp._fd

# setup virtual ethernet
veth = setup_veth(args)
tap_fd = veth.tap.get_fd()

online = False
start = time.time()
try:
  log("enter main loop")
  while True:
    status = pb.check_status()
    if status is False:
      break
    elif status is True:
      online = False
 
    # io multiplex
    r = select([tap_fd,sp_fd],[],[])
    t = time.time() - start
    
    # got packet from virtual ethernet?
    need_handle = False
    if tap_fd in r[0]:
      need_handle = handle_eth(veth, pb, t, args)
    
    # got packet from parallel?
    if sp_fd in r[0] or need_handle:
      handle_pb(pb, veth, t, args)
      
except KeyboardInterrupt:
  print
finally:
  log("shutting down")
  veth.close()
  pb.close()
  log("done")
