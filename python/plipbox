#!/usr/bin/env python2.7

from __future__ import print_function

import sys, os
import time
import argparse
import threading
import traceback

import veth
import pbvpar
from ethframe import EthFrame

# ---------- ethernet ------------------------------------------------------

class EthernetReader:

  def __init__(self, args, log):
    # setup virtual ethernet
    ifs = (args.eth_if, args.tap_if, args.bridge_if)
    v = veth.VEth(*ifs)
    if not v.pre_check_ifs():
      print("veth: interface problem!",*ifs)
      sys.exit(1)
    try:
      v.open()
    except Exception as e:
      print("veth: error opening:",e)
      sys.exit(2)
    self.eth = v
    self.args = args
    self.log = log

  def tx_pkt(self, raw_buf):
    self.eth.tx_pkt(raw_buf)

  def set_env(self, pb, leave_event, online_event, pb_mac):
    self.pb = pb
    self.leave_event = leave_event
    self.online_event = online_event
    self.pb_mac = pb_mac

  def run(self):
    try:
      self.log("starting ethernet reader")
      timeout = 0.5
      while not self.leave_event.is_set():
        # read packet
        raw_buf = self.eth.rx_pkt(timeout=timeout)
        if raw_buf is not None:
          # decode frame
          eth_frame = EthFrame()
          eth_frame.decode(raw_buf)
          # send packet to plipbox
          if not args.rx and online_event.is_set():
            # check if packet is passed
            keep = args.eth_pass or eth_frame.is_for_me(plipbox_mac)
            if keep:
              # submit to par send
              self.pb.tx_pkt(raw_buf)
              tag = " ok "
            else:
              tag = "FILT"
          else:
            tag = "OFF "
          t = time.time()
          self.log("%12.6f eth: [%4d] [%s]" % (t, len(raw_buf), tag), eth_frame)
    except KeyboardInterrupt:
      self.log("BREAK [eth]")
      self.leave_event.set()
    except Exception as e:
      self.log("Unexpected error:", e)
      traceback.print_exc()
    finally:
      self.log("closing ethernet reader")
      self.eth.close()
      self.log("ethernet done")

# ---------- plipbox -------------------------------------------------------

class PlipboxReader:

  def __init__(self, args, log):
    pb = pbvpar.PBVPar(args.vpar_link, debug=args.debug)
    try:
      pb.open()
    except Exception as e:
      print("pb: error opening:",e)
      sys.exit(3)
    self.pb = pb
    self.args = args
    self.log = log

  def tx_pkt(self, raw_buf):
    self.pb.tx_pkt(raw_buf)

  def set_env(self, eth, leave_event, online_event):
    self.eth = eth
    self.leave_event = leave_event
    self.online_event = online_event

  def run(self):
    try:
      self.log("starting plipbox reader")
      timeout = 0.5
      while not self.leave_event.is_set():
        # was a buffer received?
        raw_buf = self.pb.rx_pkt(timeout)
        if raw_buf is not None:
          # decode frame
          eth_frame = EthFrame()
          eth_frame.decode(raw_buf)
          n = len(raw_buf)
          # check for magic packets
          if eth_frame.is_magic_online():
            log("magic: online", True)
            tag = "M:ON"
            self.online_event.set()
          elif eth_frame.is_magic_offline():
            log("magic: offline", True)
            tag = "M:OF"
            self.online_event.clear()
          elif not args.rx and self.online_event.is_set():
            try:
              tag = " ok "
              self.eth.tx_pkt(raw_buf)
            except OSError as e:
              self.log(e)
              tag = "ERR!"
          else:
            tag = "OFF "
          t = time.time()
          self.log("%12.6f PAR: [%4d] [%s]" % (t,len(raw_buf), tag), eth_frame)
    except KeyboardInterrupt:
      self.log("BREAK [pb]")
      self.leave_event.set()
    except Exception as e:
      self.log("Unexpected error:", e)
      traceback.print_exc()
    finally:
      self.log("closing plipbox")
      self.pb.close()
      self.log("plipbox done")

# ---------- main -----------------------------------------------------------
print("Welcome to plipbox!")

# default param
plipbox_mac = (0x1a,0x11,0xaf,0xa0,0x47,0x11)

# parse args
parser = argparse.ArgumentParser()
parser.add_argument('-r', '--rx', action='store_true', default=False, help="only receive")

parser.add_argument('-e', '--eth-if', default="en1", help="ethernet interface name")
parser.add_argument('-t', '--tap-if', default="tap0", help="tap interface name")
parser.add_argument('-b', '--bridge-if', default="bridge1", help="bridge interface name")

parser.add_argument('-l', '--vpar-link', default="/tmp/vpar", help="link name for vpar pty")
parser.add_argument('-v', '--verbose', action='store_true', default=False, help="be verbose")
parser.add_argument('-d', '--debug', type=int, default=0, help="debug flags: 1=low level, 2=protocol")
parser.add_argument('-E', '--eth-pass', action='store_true', default=False, help="pass all packets on ethernet")
args = parser.parse_args()

def log(*v,**kw):
  global args
  if args.verbose or 'force' in kw:
    print(*v)

# setup plipbox and ethernet
eth = EthernetReader(args, log)
pb = PlipboxReader(args, log)

# setup shared env
leave_event = threading.Event()
online_event = threading.Event()
pb.set_env(eth, leave_event, online_event)
eth.set_env(pb, leave_event, online_event, plipbox_mac)

# start reader threads
eth_thread = threading.Thread(target=eth.run)
pb_thread = threading.Thread(target=pb.run)
if eth_thread is not None:
  eth_thread.start()
if pb_thread is not None:
  pb_thread.start()

# main thread waiting for leave event to be set
try:
  log("enter main loop")
  while True:
    leave_event.wait(0.5)
except KeyboardInterrupt:
  log("BREAK [main]")
  leave_event.set()

# shut down
if eth_thread is not None:
  log("joining ethernet")
  eth_thread.join()
if pb_thread is not None:
  log("joining plipbox")
  pb_thread.join()
log("done")
