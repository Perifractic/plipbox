#!/usr/bin/env python2.7

from __future__ import print_function

import sys, os
import vpar
import magplip
import time
import argparse
from select import select
import struct

# default param
par_name = "/tmp/hpar"
tap_name = "/dev/tap0"
plipbox_mac = (0x1a,0x11,0xaf,0xa0,0x47,0x11)

# parse args
parser = argparse.ArgumentParser()
parser.add_argument('-r', '--rx', action='store_true', default=False, help="only receive")
parser.add_argument('-m', '--multicast', action='store_true', default=False, help="transport IPv4 multicasts")
parser.add_argument('-v', '--verbose', action='store_true', default=False, help="be verbose")
parser.add_argument('-d', '--debug', action='store_true', default=False, help="debug code")
args = parser.parse_args()

# ----- packet to eth frame -----

def log(*v,**kv):
  global args
  if args.verbose:
    print(*v,**kv)

def raw_to_pkt(raw):
  """convert a raw ethernet frame to packet format for magplip"""
  tgt_mac = struct.unpack("BBBBBB",raw[0:6])
  src_mac = struct.unpack("BBBBBB",raw[6:12])
  eth_type = struct.unpack("!H",raw[12:14])[0]
  data = raw[14:]
  return magplip.Packet(data,eth_type,src_mac,tgt_mac)

def pkt_to_raw(pkt):
  tgt = struct.pack("BBBBBB",*pkt.tgt)
  src = struct.pack("BBBBBB",*pkt.src)
  eth_type = struct.pack("!H",pkt.ptype)
  data = pkt.data
  return tgt + src + eth_type + data

def calc_speed(delta, size):
  kibs = size / (delta * 1024)
  return "%6.3f KiB/s" % kibs

def check_pkt(pkt, args):
  global plipbox_mac
  bcast = (0xff,0xff,0xff,0xff,0xff,0xff)
  if pkt.tgt == bcast:
    if pkt.ptype == 0x800:
      return args.multicast
    else:
      return True
  elif pkt.tgt != plipbox_mac:
    return False
  else:
    return True

# ----- main loop -----
print("Welcome to plipbox!")
vpar = vpar.VPar(par_name,verbose=args.debug)
mp = magplip.MagPlip(vpar)
tapf = os.open(tap_name, os.O_RDWR)
timeout = 0.1
last_time = time.time()
try:
  print("enter loop")
  while True:

    # io multiplex
    r = select([tapf,vpar.par_file],[],[])[0]
    t = time.time()
    delta = t - last_time
    last_time = t
    
    # got packet from tap?
    if tapf in r:
      # read packet
      raw_buf = os.read(tapf, 4000)
      pkt = raw_to_pkt(raw_buf)
      log("%8.3f  tap:"%delta,pkt,end=' ')
      # send packet to magplip
      if not args.rx and check_pkt(pkt, args):
        for retry in xrange(5):
          try:
            s = time.time()
            mp.send(pkt)
            e = time.time()
            delta = e - s
            log(calc_speed(delta, len(pkt.data)),end=' ')
            break
          except magplip.MagPlipError as e:
            log(e,end=' ')
          time.sleep(0.1)
      log()
    
    # got packet from parallel?
    if vpar.par_file in r:
      has_data = mp.can_recv(timeout=1)
      if has_data:
        # rx: get block
        pkt = None
        try:
          s = time.time()
          pkt = mp.recv()
          e = time.time()
          delta = e - s
        except magplip.MagPlipError as e:
          log(e)
        if pkt != None:
          log("%8.3f  PAR:"%delta,pkt,calc_speed(delta,len(pkt.data)),end=' ')
          # send to tap
          if not args.rx:
            raw_buf = pkt_to_raw(pkt)
            try:
              os.write(tapf, raw_buf)
              log()
            except OSError as e:
              log(e)
        
except KeyboardInterrupt:
  pass

vpar.close()
os.close(tapf)
print("done")


