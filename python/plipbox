#!/usr/bin/env python2.7

from __future__ import print_function

import sys, os
import time
import argparse
from select import select
import struct

import sopty
import vpar
import pbproto
import veth

MAGIC_ONLINE = 0xffff
MAGIC_OFFLINE = 0xfffe

# default param
plipbox_mac = (0x1a,0x11,0xaf,0xa0,0x47,0x11)

# parse args
parser = argparse.ArgumentParser()
parser.add_argument('-r', '--rx', action='store_true', default=False, help="only receive")

parser.add_argument('-e', '--eth-if', default="en1", help="ethernet interface name")
parser.add_argument('-t', '--tap-if', default="tap0", help="tap interface name")
parser.add_argument('-b', '--bridge-if', default="bridge0", help="bridge interface name")

parser.add_argument('-l', '--vpar-link', default="/tmp/vpar", help="link name for vpar pty")
parser.add_argument('-v', '--verbose', action='store_true', default=False, help="be verbose")
parser.add_argument('-P', '--show-proto', action='store_true', default=False, help="show protocol")
parser.add_argument('-V', '--show-vpar', action='store_true', default=False, help="show vpar")
parser.add_argument('-E', '--eth-pass', action='store_true', default=False, help="pass all packets on ethernet")
args = parser.parse_args()

# ----- eth frame decoding -----

def log(*v,**kv):
  global args
  if args.verbose:
    print(*v,**kv)

class EthFrame:
  def __init__(self):
    self.tgt_mac = None
    self.src_mac = None
    self.eth_type = None
    self.size = 0
  
  def decode(self, raw_pkt):
    self.tgt_mac = struct.unpack("BBBBBB",raw_pkt[0:6])
    self.src_mac = struct.unpack("BBBBBB",raw_pkt[6:12])
    self.eth_type = struct.unpack("!H",raw_pkt[12:14])[0]
    self.size = len(raw_pkt) - 14

  def decode_mac(self, mac):
    res = []
    for a in mac:
      res.append("%02x" % a)
    return ":".join(res)

  def __str__(self):
    t = self.decode_mac(self.tgt_mac)
    s = self.decode_mac(self.src_mac)
    return "[%04d:0x%04x,%s->%s]" % (self.size, self.eth_type,s,t)
    
def calc_speed(delta, size):
  if delta > 0:
    kibs = size / (delta * 1024)
  else:
    kibs = 0
  return "%6.3f KiB/s" % kibs

def get_speed_bar(delta, n):
  return "%s   %12.6f s" % (
    calc_speed(delta, n), delta
  )

def check_bootp_bcast(raw_buf):
  eth_off = 14
  # check IP proto
  proto = ord(raw_buf[eth_off+9])
  if proto != 17: # must be UDP
    return False
  # check tgt ip
  off = eth_off + 16 # eth hdr + ip: tgt
  tgt_ip = struct.unpack("BBBB",raw_buf[off:off+4])
  if tgt_ip != (255,255,255,255):
    return False
  # check udp port
  udp_off = eth_off + (ord(raw_buf[eth_off]) & 0xf) * 4
  src_port = struct.unpack("!H",raw_buf[udp_off:udp_off+2])[0] 
  tgt_port = struct.unpack("!H",raw_buf[udp_off+2:udp_off+4])[0]
  bootp = (67, 68)
  return src_port in bootp and tgt_port in bootp
  
def check_pkt(pkt, raw_buf, args):
  global plipbox_mac
  bcast = (0xff,0xff,0xff,0xff,0xff,0xff)
  if pkt.tgt_mac == bcast:
    if pkt.eth_type == 0x806: # ARP
      return True
    elif pkt.eth_type == 0x800: # IPv4
      return check_bootp_bcast(raw_buf)
    else:
      return False
  elif pkt.tgt_mac != plipbox_mac:
    return False
  else:
    return True

def handle_eth(veth, pb, t, args):
  global online
  # read packet
  raw_buf = veth.rx_pkt()
  # decode frame
  eth_frame = EthFrame()
  eth_frame.decode(raw_buf)
  # send packet to plipbox
  if not args.rx and online:
    # check if packet is passed
    keep = args.eth_pass or check_pkt(eth_frame, raw_buf, args)
    if keep:
      # submit to par send
      pb.send(raw_buf)
      tag = " ok "
      return pb.must_handle()
    else:
      tag = "FILT"
  else:
    tag = "OFF "
  log("%12.6f eth: [%4d] [%s]" % (t, len(raw_buf), tag), eth_frame)
  return False

def handle_par(pb, veth, t, args):
  global online
  # rx: get block
  pkt = None
  cmd = 0
  try:
    # handle par command
    s = time.time()
    cmd,n = pb.handle()
    e = time.time()
    d = e - s
    log("%12.6f *CMD%02x* :" % (t,cmd), get_speed_bar(d,n))
  except pbproto.PBProtoError as ex:
    e = time.time()
    d = e - s
    log("%12.6f *CMD%02x* : ERROR %s. delta=%5.3f" % (t, cmd, ex, d))
  
  # was a buffer received?
  raw_buf = pb.recv()
  if raw_buf != None:
    # decode frame
    eth_frame = EthFrame()
    eth_frame.decode(raw_buf)
    n = len(raw_buf)
    # check for magic packets
    if eth_frame.eth_type == MAGIC_ONLINE:
      log("magic: online")
      tag = "M:ON"
      online = True
    elif eth_frame.eth_type == MAGIC_OFFLINE:
      log("magic: offline")
      tag = "M:OF"
      online = False
    elif not args.rx and online:
        try:
          tag = " ok "
          veth.tx_pkt(raw_buf)
        except OSError as e:
          log(e)
          tag = "ERR!"
    else:
      tag = "OFF "
    log("%12.6f PAR: [%4d] [%s]" % (t,len(raw_buf), tag), eth_frame)

def setup_veth(args):
  # setup virtual ethernet
  ifs = (args.eth_if, args.tap_if, args.bridge_if)
  v = veth.VEth(*ifs)
  if not v.pre_check_ifs():
    print("veth: interface problem!",*ifs)
    sys.exit(1)
  try:
    v.open()
  except Exception as e:
    print("veth: error opening:",e)
    sys.exit(2)
  return v

# ----- main loop -----
print("Welcome to plipbox!")

# setup vpar and plipbox protocol
vpar_link = args.vpar_link
log("opening pty:",vpar_link)
sp = sopty.SoPTY(vpar_link)
sp_fd = sp.get_fd()

log("vpar")
vpar = vpar.VPar(sp,verbose=args.show_vpar)
log("plipbox")
pb = pbproto.PBProto(vpar,debug=args.show_proto)

veth = setup_veth(args)
tap_fd = veth.tap.get_fd()

timeout = 0.1
do_sync = True
start = time.time()
try:
  log("enter main loop")
  while True:
    # need a vpar re-sync 
    if do_sync:
      log("sync vpar with emu")
      vpar.request_state()
      log("start plipbox protocol")
      pb.start()
      do_sync = False
      online = False

    # io multiplex
    r = select([tap_fd,sp_fd],[],[])
    t = time.time() - start
    
    # got packet from virtual ethernet?
    need_handle = False
    if tap_fd in r[0]:
      need_handle = handle_eth(veth, pb, t, args)
    
    # got packet from parallel?
    if sp_fd in r[0] or need_handle:
      handle_par(pb, veth, t, args)
    
    # check emulator flags in vpar
    if vpar.check_init_flag():
      log("emu restarted")
      do_sync = True
    if vpar.check_exit_flag():
      log("emu exit")
      break
      
except KeyboardInterrupt:
  print
finally:
  log("shutting down")
  veth.close()
  vpar.close()
  sp.close()
  log("done")
