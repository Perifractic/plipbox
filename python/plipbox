#!/usr/bin/env python2.7

from __future__ import print_function

import sys, os
import time
import argparse
from select import select
import struct

import sopty
import vpar
import magplip
import tap
import bridge

# default param
par_name = "/tmp/vpar"
tap_name = "tap0"
eth_name = "en1"
plipbox_mac = (0x1a,0x11,0xaf,0xa0,0x47,0x11)

# parse args
parser = argparse.ArgumentParser()
parser.add_argument('-r', '--rx', action='store_true', default=False, help="only receive")
parser.add_argument('-m', '--multicast', action='store_true', default=False, help="transport IPv4 multicasts")
parser.add_argument('-v', '--verbose', action='store_true', default=False, help="be verbose")
parser.add_argument('-d', '--debug', action='store_true', default=False, help="debug code")
args = parser.parse_args()

# ----- eth frame decoding -----

def log(*v,**kv):
  global args
  if args.verbose:
    print(*v,**kv)

class EthFrame:
  def __init__(self):
    self.tgt_mac = None
    self.src_mac = None
    self.eth_type = None
    self.size = 0
  
  def decode(self, raw_pkt):
    self.tgt_mac = struct.unpack("BBBBBB",raw_pkt[0:6])
    self.src_mac = struct.unpack("BBBBBB",raw_pkt[6:12])
    self.eth_type = struct.unpack("!H",raw_pkt[12:14])[0]
    self.size = len(raw_pkt) - 14

  def decode_mac(self, mac):
    res = []
    for a in mac:
      res.append("%02x" % a)
    return ":".join(res)

  def __str__(self):
    t = self.decode_mac(self.tgt_mac)
    s = self.decode_mac(self.src_mac)
    return "[%04d:0x%04x,%s->%s]" % (self.size, self.eth_type,s,t)
    
def calc_speed(delta, size):
  kibs = size / (delta * 1024)
  return "%6.3f KiB/s" % kibs

def get_speed_bar(delta, deltas, n):
  return "%s %s f=%4.3f l=%4.3f" % (
    calc_speed(delta, n), calc_speed(deltas[1], n),
    deltas[0], deltas[1]
  )

def check_bootp_bcast(raw_buf):
  eth_off = 14
  # check IP proto
  proto = ord(raw_buf[eth_off+9])
  if proto != 17: # must be UDP
    return False
  # check tgt ip
  off = eth_off + 16 # eth hdr + ip: tgt
  tgt_ip = struct.unpack("BBBB",raw_buf[off:off+4])
  if tgt_ip != (255,255,255,255):
    return False
  # check udp port
  udp_off = eth_off + (ord(raw_buf[eth_off]) & 0xf) * 4
  src_port = struct.unpack("!H",raw_buf[udp_off:udp_off+2])[0] 
  tgt_port = struct.unpack("!H",raw_buf[udp_off+2:udp_off+4])[0]
  bootp = (67, 68)
  return src_port in bootp and tgt_port in bootp
  
def check_pkt(pkt, raw_buf, args):
  global plipbox_mac
  bcast = (0xff,0xff,0xff,0xff,0xff,0xff)
  if pkt.tgt_mac == bcast:
    if pkt.eth_type == 0x806: # ARP
      return True
    elif pkt.eth_type == 0x800: # IPv4
      return check_bootp_bcast(raw_buf)
    else:
      return False
  elif pkt.tgt_mac != plipbox_mac:
    return False
  else:
    return True

# ----- main loop -----
print("Welcome to plipbox!")

# setup vpar and magplip
log("opening pty:",par_name)
sp = sopty.SoPTY(par_name)
sp_fd = sp.get_fd()

log("vpar")
vpar = vpar.VPar(sp,verbose=args.debug)
log("magplip")
mp = magplip.MagPlip(vpar)

# setup tap and bridge
log("opening tap:",tap_name)
tap = tap.Tap(tap_name)
tap_fd = tap.get_fd()

log("setup bridge:",tap_name,eth_name)
bridge = bridge.Bridge(tap_name, eth_name)
bridge.up()

timeout = 0.1
start = time.time()
try:
  log("enter main loop")
  while True:

    # io multiplex
    r = select([tap_fd,sp_fd],[],[])
    t = time.time() - start
    
    # got packet from tap?
    if tap_fd in r[0]:
      # read packet
      raw_buf = tap.read(4000)
      # decode frame
      eth_frame = EthFrame()
      eth_frame.decode(raw_buf)
      # send packet to magplip
      if not args.rx and check_pkt(eth_frame, raw_buf, args):
        log("%12.6f  tap:" % t , eth_frame, end=' ')
        try:
          s = time.time()
          deltas = mp.send(raw_buf)
          e = time.time()
          d = e - s
          n = len(raw_buf)
          log(get_speed_bar(d, deltas, n))
        except magplip.MagPlipError as e:
          log(e)
    
    # got packet from parallel?
    if sp_fd in r[0]:
      # rx: get block
      pkt = None
      try:
        # receive frame
        s = time.time()
        raw_buf,deltas = mp.recv()
        e = time.time()
        d = e - s
        if raw_buf != None:
          # decode frame
          eth_frame = EthFrame()
          eth_frame.decode(raw_buf)
          n = len(raw_buf)
          log("%12.6f *PAR:" % t, eth_frame, get_speed_bar(d,deltas,n), end=' ')
          # send to tap
          if not args.rx:
            try:
              tap.write(raw_buf)
              log()
            except OSError as e:
              log(e)
      except magplip.MagPlipError as e:
        log(e)
        
except KeyboardInterrupt:
  print
finally:
  log("shutting down")
  bridge.down()
  tap.close()
  vpar.close()
  sp.close()
  log("done")
